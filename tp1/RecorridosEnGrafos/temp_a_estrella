"""
------------------
si comienzo == final termina

vecinos, visitados, camino = []

vecinos.push_back(inicio)

# para cada vecino [de uno ya visitado!] buscaré los adyacentes (sus vecinos)
mientras vecinos not empty / for v in vecinos:
	encontrado = false
	for nodo in v->adyacentes:
		# para cada adyacente, me fijo que no haber vuelto al "padre"
		if (nodo no tiene padre || nodo->padre != v):
			# si es el final, lo guardo como posibilidad
			if (nodo == final):
				if (!encontrado || nodo.f() < nodoFinal.f()):
					nodoFinal = nodo
				encontrado = true
			# si no fue visitado ya, lo agregaré a vecinos
			elif nodo not in visitados:
				# si ya estaba guardo el que tenga menor G
				if nodo not in vecinos:
					vecinos.insertar_ordenado_por_f(nodo)
				else:
					c = vecinos.buscar(nodo)
					nuevoG = v.g + arista(v, c)
					if (nuevoG < c.g):
						vecinos.borrar(c)
						c.g = nuevoG
						# ordenado por f para sacar siempre el de menor
						vecinos.insertar_ordenado_por_f(c)
	# si encontré un nodo final desde este v, armo el camino y salgo
	if (encontrado == true)
		v = nodoFinal
		while (v != inicio)
			camino.insertar(v)
			v = v.padre
		camino.invertir
		break
	# si no, saco v de vecinos y lo agrego a visitados
	visitados.push_back(v)
	vecinos.borrar(v)

limpieza vecinos y visitados
return camino
------------------

Nota: f = g + h
g es la distancia que se recorrió hasta llegar al nodo, por eso siempre se busca guardar la menor para minimizar el camino
h es la heurística, que en este caso fue la distancia al destino
Minimizar f es tironear para ambos lados
"""
